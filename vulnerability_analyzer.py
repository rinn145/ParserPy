import tkinter as tk
from tkinter import ttk, messagebox  # Импорт дополнительных модулей из tkinter
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
# Импорт класса для встраивания графики Matplotlib в Tkinter
import matplotlib.pyplot as plt  # Импорт модуля Matplotlib
import pandas as pd  # Импорт модуля Pandas для работы с данными
from docx import Document


class VulnerabilityAnalyzer:
    # Иницаализация основного класса
    def __init__(self, master):
        # Инициализация основного окна приложения
        self.root = master
        self.root.title("Анализ уязвимостей")  # Заголовок окна
        self.apply_styles()  # Применение стилей к приложению
        self.graph_frame = ttk.Frame(self.root)
        self.graph_frame.pack(padx=20, pady=20)

        # Создание фрейма для размещения элементов интерфейса
        self.frame = ttk.Frame(self.root)
        self.frame.pack(padx=20, pady=20)  # Упаковка фрейма на основное окно с отступами

        # Создание метки и поля ввода для ключевого слова
        self.label_keyword = tk.Label(self.frame, text="Введите ключевое слово:")
        self.label_keyword.grid(row=0, column=0, padx=10, pady=5)  # Размещение метки на фрейме
        self.entry_keyword = tk.Entry(self.frame, width=30)
        self.entry_keyword.grid(row=0, column=1, padx=10, pady=5)  # Размещение поля ввода на фрейме
        self.entry_keyword.focus()  # Установка фокуса на поле ввода

        # Создание кнопок "Найти" и "Очистить"
        self.Button_find = tk.Button(self.frame, text='Найти', command=self.func_add)
        self.Button_find.grid(row=0, column=2, padx=10, pady=5)  # Размещение кнопки "Найти" на фрейме
        self.Button_clear = tk.Button(self.frame, text='Очистить', command=self.clear_entry)
        self.Button_clear.grid(row=0, column=3, padx=10, pady=5)  # Размещение кнопки "Очистить" на фрейме
        self.Button_export_word = tk.Button(self.frame, text='Экспорт в Word', command=self.export_to_word_wrapper)
        self.Button_export_word.grid(row=5, column=0, columnspan=5, padx=10, pady=10)  # Размещение кнопки

        # Создание меток для вывода результатов анализа
        self.label_result_K = tk.Label(self.frame, text="Критический", width=20)
        self.label_result_K.grid(row=1, column=0, padx=10, pady=5)  # Размещение метки для критических результатов
        self.label_result_K_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_K_R.grid(row=1, column=1, padx=10,
                                   pady=5)  # Размещение метки для количества критических результатов
        # Аналогично создаются метки для других уровней уязвимостей: "Высокий", "Средний", "Низкий"
        self.label_result_H = tk.Label(self.frame, text="Высокий", width=20)
        self.label_result_H.grid(row=2, column=0, padx=10, pady=5)
        self.label_result_H_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_H_R.grid(row=2, column=1, padx=10, pady=5)
        self.label_result_S = tk.Label(self.frame, text="Средний", width=20)
        self.label_result_S.grid(row=3, column=0, padx=10, pady=5)
        self.label_result_S_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_S_R.grid(row=3, column=1, padx=10, pady=5)
        self.label_result_L = tk.Label(self.frame, text="Низкий", width=20)
        self.label_result_L.grid(row=4, column=0, padx=10, pady=5)
        self.label_result_L_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_L_R.grid(row=4, column=1, padx=10, pady=5)

        # Создание комбобокса для выбора типа графика
        self.chart_type_combo = ttk.Combobox(self.frame, values=["Круговая", "Столбчатая"], width=20, state="readonly")
        self.chart_type_combo.grid(row=0, column=4, padx=10, pady=5)  # Размещение комбобокса на фрейме
        self.chart_type_combo.current(0)  # Установка значения по умолчанию

        # Применение стилей к приложению

    def export_to_word_wrapper(self):
        threat_count_critical = int(self.label_result_K_R.cget("text"))
        threat_count_high = int(self.label_result_H_R.cget("text"))
        threat_count_medium = int(self.label_result_S_R.cget("text"))
        threat_count_low = int(self.label_result_L_R.cget("text"))
        self.export_to_word(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low)

    @staticmethod
    def export_to_word(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low):
        try:
            # Создаем новый документ Word
            doc = Document()

            # Добавляем заголовок
            doc.add_heading('Результаты анализа уязвимостей', level=1)

            # Добавляем таблицу с результатами
            table = doc.add_table(rows=5, cols=2)
            table.cell(0, 0).text = 'Уровень уязвимости'
            table.cell(0, 1).text = 'Количество'

            # Заполняем таблицу данными
            table.cell(1, 0).text = 'Критический'
            table.cell(1, 1).text = str(threat_count_critical)
            table.cell(2, 0).text = 'Высокий'
            table.cell(2, 1).text = str(threat_count_high)
            table.cell(3, 0).text = 'Средний'
            table.cell(3, 1).text = str(threat_count_medium)
            table.cell(4, 0).text = 'Низкий'
            table.cell(4, 1).text = str(threat_count_low)

            # Сохраняем документ
            doc.save('results.docx')

            # Вывод информационного сообщения об успешном экспорте
            messagebox.showinfo("Экспорт завершен",
                                "Результаты анализа уязвимостей успешно экспортированы в файл results.docx")
        except Exception as e:
            # Вывод сообщения об ошибке при экспорте
            messagebox.showerror("Ошибка при экспорте", f"Произошла ошибка при экспорте в Word: {e}")

    def apply_styles(self):
        self.root.option_add('*Font', 'Helvetica 12')  # Установка шрифта
        self.root.option_add('*Background', 'white')  # Установка фона
        self.root.option_add('*Foreground', '#333')  # Установка цвета текста
        self.root.option_add('*BorderWidth', 2)  # Установка ширины границ

        style = ttk.Style()  # Создание объекта стилей
        style.configure('TFrame', background='white')  # Конфигурация стиля фрейма
        style.configure('TButton', background='#4CAF50', foreground='white', font=('Helvetica', 12), padding=10)
        # Конфигурация стиля кнопки

        # Функция для выполнения анализа по ключевому слову

    def func_add(self):
        try:
            keyword = self.entry_keyword.get().strip()  # Получение ключевого слова из поля ввода
            if not keyword:  # Проверка на пустое ключевое слово
                messagebox.showwarning("Пустое ключевое слово", "Пожалуйста, введите ключевое слово для поиска.")
                return

            # Инициализация счетчиков для разных уровней уязвимостей
            threat_count_low = 0
            threat_count_medium = 0
            threat_count_high = 0
            threat_count_critical = 0

            # Загрузка данных из файла Excel
            df = pd.read_excel('vullist.xlsx', header=2)

            # Перебор строк и столбцов в DataFrame для поиска уязвимостей
            for index, row in df.iterrows():
                for column in df.columns:
                    if keyword.lower() in str(row[column]).lower() and pd.notna(row['Уровень опасности уязвимости']):
                        # Если уязвимость найдена и имеет уровень опасности, увеличиваем соответствующий счетчик
                        if "Низкий" in row['Уровень опасности уязвимости']:
                            threat_count_low += 1
                        elif "Средний" in row['Уровень опасности уязвимости']:
                            threat_count_medium += 1
                        elif "Высокий" in row['Уровень опасности уязвимости']:
                            threat_count_high += 1
                        elif "Критический" in row['Уровень опасности уязвимости']:
                            threat_count_critical += 1
                        break  # Прерываем внутренний цикл, чтобы не проверять остальные столбцы

            # Обновление меток с количеством найденных уязвимостей
            self.label_result_K_R.config(text=str(threat_count_critical))
            self.label_result_H_R.config(text=str(threat_count_high))
            self.label_result_S_R.config(text=str(threat_count_medium))
            self.label_result_L_R.config(text=str(threat_count_low))

            # Построение графика в зависимости от выбранного типа
            if self.chart_type_combo.get() == "Круговая":
                self.create_pie_chart(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low)
            elif self.chart_type_combo.get() == "Столбчатая":
                self.create_bar_chart(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low)

        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для создания круговой диаграммы

    def create_pie_chart(self, threat_count_critical, threat_count_high, threat_count_medium, threat_count_low):
        try:
            labels = ['Критический', 'Высокий', 'Средний', 'Низкий']  # Метки для круговой диаграммы
            counts = [threat_count_critical, threat_count_high, threat_count_medium,
                      threat_count_low]  # Данные для круговой диаграммы
            fig, ax = plt.subplots()  # Создание объекта графика
            ax.pie(counts, labels=labels, autopct='%1.1f%%', startangle=140)  # Построение круговой диаграммы
            ax.axis('equal')  # Установка одинакового масштаба по обеим осям
            self.plot_chart(fig)  # Отображение графика на интерфейсе
        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для создания столбчатой диаграммы

    def create_bar_chart(self, threat_count_critical, threat_count_high, threat_count_medium, threat_count_low):
        try:
            labels = ['Критический', 'Высокий', 'Средний', 'Низкий']  # Метки для столбчатой диаграммы
            counts = [threat_count_critical, threat_count_high, threat_count_medium,
                      threat_count_low]  # Данные для столбчатой диаграммы
            fig, ax = plt.subplots()  # Создание объекта графика
            ax.bar(labels, counts, color=['red', 'orange', 'yellow', 'green'])  # Построение столбчатой диаграммы
            self.plot_chart(fig)  # Отображение графика на интерфейсе
        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для отображения графика на интерфейсе

    def plot_chart(self, fig):
        try:
            # Очистка фрейма с графиком перед добавлением нового
            for widget in self.graph_frame.winfo_children():
                widget.destroy()

            # Создание канвы и размещение графика на отдельном фрейме
            canvas = FigureCanvasTkAgg(fig, master=self.graph_frame)
            canvas.draw()
            canvas.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

    # Функция для очистки поля ввода
    def clear_entry(self):
        self.entry_keyword.delete(0, tk.END)  # Удаление текста из поля ввода

