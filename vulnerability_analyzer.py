import tkinter as tk
from tkinter import ttk, messagebox  # Импорт дополнительных модулей из tkinter
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
# Импорт класса для встраивания графики Matplotlib в Tkinter
import matplotlib.pyplot as plt  # Импорт модуля Matplotlib
import pandas as pd  # Импорт модуля Pandas для работы с данными


class VulnerabilityAnalyzer:
    # Иницаализация основного класса
    def __init__(self, master):
        # Инициализация основного окна приложения
        self.root = master
        self.root.title("Анализ уязвимостей")  # Заголовок окна
        self.apply_styles()  # Применение стилей к приложению

        # Создание фрейма для размещения элементов интерфейса
        self.frame = ttk.Frame(self.root)
        self.frame.pack(padx=20, pady=20)  # Упаковка фрейма на основное окно с отступами

        # Создание метки и поля ввода для ключевого слова
        self.label_keyword = tk.Label(self.frame, text="Введите ключевое слово:")
        self.label_keyword.grid(row=0, column=0, padx=10, pady=5)  # Размещение метки на фрейме
        self.entry_keyword = tk.Entry(self.frame, width=30)
        self.entry_keyword.grid(row=0, column=1, padx=10, pady=5)  # Размещение поля ввода на фрейме
        self.entry_keyword.focus()  # Установка фокуса на поле ввода

        # Создание кнопок "Найти" и "Очистить"
        self.Button_find = tk.Button(self.frame, text='Найти', command=self.func_add)
        self.Button_find.grid(row=0, column=2, padx=10, pady=5)  # Размещение кнопки "Найти" на фрейме
        self.Button_clear = tk.Button(self.frame, text='Очистить', command=self.clear_entry)
        self.Button_clear.grid(row=0, column=3, padx=10, pady=5)  # Размещение кнопки "Очистить" на фрейме

        # Создание меток для вывода результатов анализа
        self.label_result_K = tk.Label(self.frame, text="Критический", width=20)
        self.label_result_K.grid(row=1, column=0, padx=10, pady=5)  # Размещение метки для критических результатов
        self.label_result_K_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_K_R.grid(row=1, column=1, padx=10,
                                   pady=5)  # Размещение метки для количества критических результатов
        # Аналогично создаются метки для других уровней уязвимостей: "Высокий", "Средний", "Низкий"
        self.label_result_H = tk.Label(self.frame, text="Высокий", width=20)
        self.label_result_H.grid(row=2, column=0, padx=10, pady=5)
        self.label_result_H_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_H_R.grid(row=2, column=1, padx=10, pady=5)
        self.label_result_S = tk.Label(self.frame, text="Средний", width=20)
        self.label_result_S.grid(row=3, column=0, padx=10, pady=5)
        self.label_result_S_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_S_R.grid(row=3, column=1, padx=10, pady=5)
        self.label_result_L = tk.Label(self.frame, text="Низкий", width=20)
        self.label_result_L.grid(row=4, column=0, padx=10, pady=5)
        self.label_result_L_R = tk.Label(self.frame, width=20, text='0')
        self.label_result_L_R.grid(row=4, column=1, padx=10, pady=5)

        # Создание комбобокса для выбора типа графика
        self.chart_type_combo = ttk.Combobox(self.frame, values=["Круговая", "Столбчатая"], width=20, state="readonly")
        self.chart_type_combo.grid(row=0, column=4, padx=10, pady=5)  # Размещение комбобокса на фрейме
        self.chart_type_combo.current(0)  # Установка значения по умолчанию

        # Применение стилей к приложению

    def apply_styles(self):
        self.root.option_add('*Font', 'Helvetica 12')  # Установка шрифта
        self.root.option_add('*Background', 'white')  # Установка фона
        self.root.option_add('*Foreground', '#333')  # Установка цвета текста
        self.root.option_add('*BorderWidth', 2)  # Установка ширины границ

        style = ttk.Style()  # Создание объекта стилей
        style.configure('TFrame', background='white')  # Конфигурация стиля фрейма
        style.configure('TButton', background='#4CAF50', foreground='white', font=('Helvetica', 12), padding=10)
        # Конфигурация стиля кнопки

        # Функция для выполнения анализа по ключевому слову

    def func_add(self):
        try:
            keyword = self.entry_keyword.get().strip()  # Получение ключевого слова из поля ввода
            if not keyword:  # Проверка на пустое ключевое слово
                messagebox.showwarning("Пустое ключевое слово", "Пожалуйста, введите ключевое слово для поиска.")
                return

            # Инициализация счетчиков для разных уровней уязвимостей
            threat_count_low = 0
            threat_count_medium = 0
            threat_count_high = 0
            threat_count_critical = 0

            # Загрузка данных из файла Excel
            df = pd.read_excel('vullist.xlsx', header=2)

            # Перебор строк и столбцов в DataFrame для поиска уязвимостей
            for index, row in df.iterrows():
                for column in df.columns:
                    if keyword.lower() in str(row[column]).lower() and pd.notna(row['Уровень опасности уязвимости']):
                        # Если уязвимость найдена и имеет уровень опасности, увеличиваем соответствующий счетчик
                        if "Низкий" in row['Уровень опасности уязвимости']:
                            threat_count_low += 1
                        elif "Средний" in row['Уровень опасности уязвимости']:
                            threat_count_medium += 1
                        elif "Высокий" in row['Уровень опасности уязвимости']:
                            threat_count_high += 1
                        elif "Критический" in row['Уровень опасности уязвимости']:
                            threat_count_critical += 1
                        break  # Прерываем внутренний цикл, чтобы не проверять остальные столбцы

            # Обновление меток с количеством найденных уязвимостей
            self.label_result_K_R.config(text=str(threat_count_critical))
            self.label_result_H_R.config(text=str(threat_count_high))
            self.label_result_S_R.config(text=str(threat_count_medium))
            self.label_result_L_R.config(text=str(threat_count_low))

            # Построение графика в зависимости от выбранного типа
            if self.chart_type_combo.get() == "Круговая":
                self.create_pie_chart(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low)
            elif self.chart_type_combo.get() == "Столбчатая":
                self.create_bar_chart(threat_count_critical, threat_count_high, threat_count_medium, threat_count_low)

        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для создания круговой диаграммы

    def create_pie_chart(self, threat_count_critical, threat_count_high, threat_count_medium, threat_count_low):
        try:
            labels = ['Критический', 'Высокий', 'Средний', 'Низкий']  # Метки для круговой диаграммы
            counts = [threat_count_critical, threat_count_high, threat_count_medium,
                      threat_count_low]  # Данные для круговой диаграммы
            fig, ax = plt.subplots()  # Создание объекта графика
            ax.pie(counts, labels=labels, autopct='%1.1f%%', startangle=140)  # Построение круговой диаграммы
            ax.axis('equal')  # Установка одинакового масштаба по обеим осям
            self.plot_chart(fig)  # Отображение графика на интерфейсе
        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для создания столбчатой диаграммы

    def create_bar_chart(self, threat_count_critical, threat_count_high, threat_count_medium, threat_count_low):
        try:
            labels = ['Критический', 'Высокий', 'Средний', 'Низкий']  # Метки для столбчатой диаграммы
            counts = [threat_count_critical, threat_count_high, threat_count_medium,
                      threat_count_low]  # Данные для столбчатой диаграммы
            fig, ax = plt.subplots()  # Создание объекта графика
            ax.bar(labels, counts, color=['red', 'orange', 'yellow', 'green'])  # Построение столбчатой диаграммы
            self.plot_chart(fig)  # Отображение графика на интерфейсе
        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для отображения графика на интерфейсе

    def plot_chart(self, fig):
        try:
            canvas = FigureCanvasTkAgg(fig, master=self.frame)  # Создание объекта канвы для отображения графика
            canvas.draw()  # Отрисовка графика на канве
            canvas.get_tk_widget().grid(row=1, column=2, rowspan=5, padx=10, pady=10)  # Размещение канвы на фрейме
        except Exception as e:
            # Вывод сообщения об ошибке в случае исключения
            messagebox.showerror("Ошибка", f"Произошла ошибка: {e}")

        # Функция для очистки поля ввода

    def clear_entry(self):
        self.entry_keyword.delete(0, tk.END)  # Удаление текста из поля ввода
